using System;
using System.Collections;
using System.Collections.Generic;
using UnityEditor.WebGL.Il2Cpp;
using UnityEngine;


[ExecuteInEditMode]
public class RealtimeTester:MonoBehaviour
{
    static RealtimeTester singleton;

    public BoolVarValue use;

    public float editorRunTestsEvery = 5;
    public float runtimeRunTestsEvery = 5;
    public float editorSearchSceneEvery = 30;
    public float runtimeSearchSceneEvery = 30;

    public List<Failure> failedTests;

    Coroutine testRunner, testableSearcher;

    MonoBehaviour[] sceneCache;
    bool[] testable;

    // Only items from scene cache that are testable
    List<ITestable> testableCache;
    static RealtimeTester Singleton {
        get {
            if (singleton == null) singleton = GameObject.FindObjectOfType<RealtimeTester>();
            if (singleton == null)
            {
                Debug.Log("[Singletons] RealtimeTester isnt in scene. Adding it manually.");
                singleton = new GameObject("[AutoGeneratedSingleton] Realtime tester").AddComponent<RealtimeTester>();
            }
            return singleton;
        }
    }

    public void RunExternally()
    {
        EnsureTestsRun();
    }


    private void Start()
    {
        EnsureTestsRun();
    }

    private void Update()
    {
        EnsureTestsRun();
    }

    private void OnRenderObject()
    {
        EnsureTestsRun();
    }
    private void OnDestroy()
    {
        singleton = null;
    }
    void EnsureTestsRun()
    {
        if (testableCache == null) testableCache = new List<ITestable>();
        if (failedTests == null) failedTests = new List<Failure>();
        if (testableSearcher == null)
            testableSearcher = StartCoroutine(FindNewTargets());
        if (testRunner == null)
        {
            Debug.Log("Rerunning test runner.");
            testRunner = StartCoroutine(RunTests());
        }
    }
    internal static void Assert(bool assertTrue, MonoBehaviour unityClass, string message)
    {
        if (!assertTrue)
            Err(unityClass, message);
    }
    internal static void Assert(bool assertTrue, object source, string message)
    {
        if (!assertTrue)
            Err(source, message);
    }
    internal static void Err(object source, string v)
    {
        Singleton.AddFailure(new Failure(source, v));
    }

    internal static void AssertSceneReference(MonoBehaviour script, MonoBehaviour source)
    {
        if (!Application.isPlaying || Time.time < 1)
            Assert(script != null, source, "[1]Some script isn't assigned in inspector."+ source.GetType());
    }
    internal static void AssertSceneReference(MonoBehaviour script, MonoBehaviour source, string msg)
    {
        if (!Application.isPlaying || Time.time < 1)
            Assert(script != null, source, "[2]Some script isn't assigned in inspector. " + msg);
    }

    internal static void Err(MonoBehaviour source, string v)
    {
        Singleton.AddFailure(new Failure(source, v));
    }
    private void AddFailure(Failure failure)
    {
        failedTests.Add(failure);
    }

    private IEnumerator FindNewTargets()
    {
        while (true)
        {
            if (!use.Value) {
                yield return new WaitForSeconds(1);
                continue;
            }

            sceneCache = GameObject.FindObjectsOfType<MonoBehaviour>();
            testable = new bool[sceneCache.Length];
            testableCache.Clear();
            ResetFailures();
            for (int i = 0; i < sceneCache.Length; i++)
            {
                testable[i] = sceneCache[i] as ITestable != null;

                // log
                if(testable[i])
                {
                    AddTestableObject(sceneCache[i] as ITestable);
                }    
            }
            yield return new WaitForSeconds(GetSearchCycle());
        }
    }
    void AddTestableObject(ITestable it)
    {
        testableCache.Add(it);
    }

    public static void DestroyedTestableObject(ITestable it)
    {
        Singleton.testableCache.Remove(it);
    }

    float GetSearchCycle()
    {
        if (!Application.isPlaying)
            return editorSearchSceneEvery;
        return runtimeSearchSceneEvery;
    }


    private IEnumerator RunTests()
    {
        yield return null; // wait 1 frame to skip start.
        while (true)
        {
            if (!use.Value)
            {
                yield return new WaitForSeconds(1);
                continue;
            }

            RunTestsInSceneOnce();

            yield return new WaitForSeconds(GetTestRunCycle());
        }
    }

    [ContextMenu("Run")]
    private void RunTestsInSceneOnce()
    {
        ResetFailures();
        for (int i = 0; i < testable.Length; i++)
        {
            if (testable[i])
            {
                ((ITestable)sceneCache[i]).TestInitialState();
            }
        }
        if (failedTests.Count > 0)
        {
            if (failedTests[0].Mono)
            {
                Debug.LogErrorFormat(failedTests[0].Mono, "[RealtimeTester] Test Failures = {0}. [0]={1}", failedTests.Count, failedTests[0].Message);
            }
            else
            {
                Debug.LogErrorFormat("[RealtimeTester] Test Failures = {0} Object: {1}. [0]={2}", failedTests.Count, failedTests[0].AdditionalObject, failedTests[0].Message);
            }
        }
    }

    private void ResetFailures()
    {
        failedTests.Clear();
    }


    float GetTestRunCycle()
    {
        if(!Application.isPlaying)
            return editorRunTestsEvery;
        return runtimeRunTestsEvery;
    }

    internal static void Deployment(bool isDeployed, MonoBehaviour source, string msgIfFail)
    {
        Assert(isDeployed, source, msgIfFail);
        if (isDeployed)
            Debug.Log("Deployment for " + source + " completed succesfully.");
    }

    [System.Serializable]
    public class Failure
    {
        // Has to be single class, to get it visible in inspector.
        [SerializeField] MonoBehaviour mono;
        [SerializeField] string msg;
        [SerializeField] object obj;

        public Failure(MonoBehaviour source, string v)
        {
            this.mono = source;
            this.msg = v;
        }

        public Failure(object source, string v)
        {
            this.obj = source;
            this.msg = v;
        }

        public string Message { get => msg; }
        public object AdditionalObject { get => mono != null ? mono : obj; }
        public MonoBehaviour Mono { get => mono; }
    }

}