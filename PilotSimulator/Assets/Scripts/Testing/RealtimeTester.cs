using System;
using System.Collections;
using System.Collections.Generic;
using UnityEditor.WebGL.Il2Cpp;
using UnityEngine;
[ExecuteInEditMode]
public class RealtimeTester:MonoBehaviour
{
    static RealtimeTester singleton;
    static RealtimeTester Singleton {
        get {
            if (singleton == null) singleton = GameObject.FindObjectOfType<RealtimeTester>();
            if (singleton == null)
            {
                Debug.Log("[Singletons] RealtimeTester isnt in scene. Adding it manually.");
                singleton = new GameObject("[AutoGeneratedSingleton] Realtime tester").AddComponent<RealtimeTester>();
            }
            return singleton;
        }
    }

    public BoolVarValue use;

    public float runTestsEvery = 5;
    public float searchSceneEvery = 30;
    
    public List<Failure> failedTests;

    Coroutine testRunner, testableSearcher;

    MonoBehaviour[] sceneCache;
    bool[] testable;

    // Only items from scene cache that are testable
    List<ITestable> testableCache;

    [System.Serializable]
    public class Failure
    {
        public MonoBehaviour mono;
        public string msg;

        public Failure(MonoBehaviour source, string v)
        {
            this.mono = source;
            this.msg = v;
        }
    }

    internal static void Assert(bool assertTrue, MonoBehaviour mono, string msg)
    {
        if (!assertTrue)
            Err(mono, msg);
    }


    void AddTestableObject(ITestable it)
    {
        testableCache.Add(it);
    }

    internal static void Err(MonoBehaviour source, string v)
    {
        Singleton.AddFailure(new Failure(source, v));
    }

    private void AddFailure(Failure failure)
    {
        failedTests.Add(failure);
    }

    private void ResetFailures()
    {
        failedTests.Clear();
    }

    void RemoveTestableLog(ITestable it)
    {
        testableCache.Remove(it);
    }

    private void Start()
    {
        EnsureTestsRun();
    }

    private void Update()
    {
        EnsureTestsRun();
    }

    private void OnGUI()
    {
        EnsureTestsRun();
    }

    private void OnRenderObject()
    {
        EnsureTestsRun();
    }

    public void RunExternally()
    {
        EnsureTestsRun();
    }

    void EnsureTestsRun()
    {
        if (testableCache == null) testableCache = new List<ITestable>();
        if (failedTests == null) failedTests = new List<Failure>();
        if (testableSearcher == null)
            testableSearcher = StartCoroutine(FindNewTargets());
        if (testRunner == null)
        {
            Debug.Log("Rerunning test runner.");
            testRunner = StartCoroutine(RunTests());
        }
    }

    private IEnumerator FindNewTargets()
    {
        while (true)
        {
            if (!use.Value) {
                yield return new WaitForSeconds(1);
                continue;
            }

            sceneCache = GameObject.FindObjectsOfType<MonoBehaviour>();
            testable = new bool[sceneCache.Length];
            testableCache.Clear();
            ResetFailures();
            for (int i = 0; i < sceneCache.Length; i++)
            {
                testable[i] = sceneCache[i] as ITestable != null;

                // log
                if(testable[i])
                {
                    AddTestableObject(sceneCache[i] as ITestable);
                }    
            }
            yield return new WaitForSeconds(searchSceneEvery);
        }
    }
    private IEnumerator RunTests()
    {
        while (true)
        {
            if (!use.Value)
            {
                yield return new WaitForSeconds(1);
                continue;
            }
            ResetFailures();
            for (int i = 0; i < testable.Length; i++)
            {
                if (testable[i])
                {
                    ((ITestable)sceneCache[i]).TestInitialState();
                }
            }
            if (failedTests.Count > 0)
            {
                Debug.LogErrorFormat(failedTests[0].mono, "[RealtimeTester] Test Failures = {0}. [0]={1}", failedTests.Count, failedTests[0].msg);
            }
            yield return new WaitForSeconds(runTestsEvery);
        }
    }
    private void OnDestroy()
    {
        singleton = null;
    }
}
